#' @title Simulate biomarker kinetics predicted by the given biokinetics priors
#' and optionally compare to a dataset.
#' @export
#' @description Simulate trajectories by drawing random samples from the given
#' priors for each parameter in the biokinetics model.
#' @return A ggplot2 object.
#' @param x A named list of type 'biokinetics_priors'.
#' @param \dots Further arguments passed to the method.
#' @param tmax Integer. The number of time points in each simulated trajectory. Default 150.
#' @param n_draws Integer. The number of trajectories to simulate. Default 2000.
#' @param data Optional data.frame with columns time_since_last_exp and value. The raw data to compare to.
#' @param upper_censoring_limit Optional upper detection limit.
#' @param lower_censoring_limit Optional lower detection limit.
plot.biokinetics_priors <- function(x,
                                    ...,
                                    tmax = 150,
                                    n_draws = 2000,
                                    data = NULL,
                                    upper_censoring_limit = NULL,
                                    lower_censoring_limit = NULL) {

  # Declare variables to suppress notes when compiling package
  # https://github.com/Rdatatable/data.table/issues/850#issuecomment-259466153
  t0 <- tp <- ts <- m1 <- m2 <- m3 <- NULL
  time_since_last_exp <- me <- lo <- hi <- value <- mu <- NULL

  if (!is.null(data)) {
    validate_required_cols(data, c("time_since_last_exp", "value"))
  }
  params <- data.table(
    t0 = stats::rnorm(n_draws, x$mu_t0, x$sigma_t0), # titre value at t0
    tp = stats::rnorm(n_draws, x$mu_tp, x$sigma_tp), # time of peak
    ts = stats::rnorm(n_draws, x$mu_ts, x$sigma_ts), # time of set point
    m1 = stats::rnorm(n_draws, x$mu_m1, x$sigma_m1), # gradient 1
    m2 = stats::rnorm(n_draws, x$mu_m2, x$sigma_m2), # gradient 2
    m3 = stats::rnorm(n_draws, x$mu_m3, x$sigma_m3) # gradient 3
  )

  times <- data.table(t = 1:tmax)
  params_and_times <- times[, as.list(params), by = times]

  params_and_times[, mu := biokinetics_simulate_trajectory(t, t0, tp, ts, m1, m2, m3),
                     by = c("t", "t0", "tp", "ts", "m1", "m2", "m3")]

  summary <- params_and_times[, .(me = stats::quantile(mu, 0.5, names = FALSE),
                                  lo = stats::quantile(mu, 0.025, names = FALSE),
                                  hi = stats::quantile(mu, 0.975, names = FALSE)), by = t]

  plot <- ggplot(summary) +
    geom_line(aes(x = t, y = me)) +
    geom_ribbon(aes(x = t, ymin = lo, ymax = hi), alpha = 0.5)

  if (!is.null(data)) {
    dat <- data[time_since_last_exp <= tmax,]
    plot <- plot +
      geom_point(data = dat, size = 0.5,
                 aes(x = time_since_last_exp,
                     y = value))

    plot <- add_limits(plot, upper_censoring_limit, lower_censoring_limit)
  }
  plot
}

#' @title Plot serological data
#' @export
#' @description Plot serological data in the format provided to the biokinetics
#' model, with a smoothing function fitted.
#' @return A ggplot2 object.
#' @param data A data.table with required columns time_since_last_exp, value and titre_type.
#' @param tmax Integer. The number of time points in each simulated trajectory. Default 150.
#' @param covariates Optional vector of covariate names to facet by (these must correspond to columns in the data.table)
#' @param upper_censoring_limit Optional upper detection limit.
#' @param lower_censoring_limit Optional lower detection limit.
plot_sero_data <- function(data,
                           tmax = 150,
                           covariates = character(0),
                           upper_censoring_limit = NULL,
                           lower_censoring_limit = NULL) {
  validate_required_cols(data, c("time_since_last_exp", "value", "titre_type"))
  data <- data[time_since_last_exp <= tmax,]
  # Declare variables to suppress notes when compiling package
  # https://github.com/Rdatatable/data.table/issues/850#issuecomment-259466153
  time_since_last_exp <- value <- titre_type <- NULL

  plot <- ggplot(data) +
    geom_point(aes(x = time_since_last_exp, y = value, colour = titre_type),
               size = 0.5, alpha = 0.5) +
    geom_smooth(aes(x = time_since_last_exp, y = value, colour = titre_type)) +
    facet_wrap(eval(parse(text = facet_formula(covariates)))) +
    guides(colour = guide_legend(title = "Titre type"))

  add_limits(plot, upper_censoring_limit, lower_censoring_limit)
}

#' Plot method for "biokinetics_population_trajectories" class
#'
#' @param x An object of class "biokinetics_population_trajectories". These are
#' generated by running biokinetics$simulate_population_trajectories(). See
#' \href{../../epikinetics/html/biokinetics.html#method-biokinetics-simulate_population_trajectories}{\code{biokinetics$simulate_population_trajectories()}}
#' @param \dots Further arguments passed to the method.
#' @param data Optional data.table containing raw data as provided to the biokinetics model.
#' @export
plot.biokinetics_population_trajectories <- function(x, ...,
                                                     data = NULL) {
  covariates <- attr(x, "covariates")
  upper_censoring_limit <- attr(x, "upper_censoring_limit")
  lower_censoring_limit <- attr(x, "lower_censoring_limit")

  # Declare variables to suppress notes when compiling package
  # https://github.com/Rdatatable/data.table/issues/850#issuecomment-259466153
  time_since_last_exp <- value <- me <- titre_type <- lo <- hi <- NULL
  day <- last_exp_day <- mu <- .draw <- NULL

  if (attr(x, "summarised")) {
    plot <- ggplot(x) +
      geom_line(aes(x = time_since_last_exp, y = me, colour = titre_type)) +
      geom_ribbon(aes(x = time_since_last_exp,
                      ymin = lo,
                      ymax = hi,
                      fill = titre_type), alpha = 0.5)
  } else {
    plot <- ggplot(x) +
      geom_line(aes(x = time_since_last_exp, y = mu,
                    colour = titre_type, group = .draw), alpha = 0.1, linewidth = 0.1)
  }
  if (!is.null(data)) {
    validate_required_cols(data)
    plot <- plot +
      geom_point(data = data,
                 aes(x = as.integer(day - last_exp_day, units = "days"),
                     y = value), size = 0.5, alpha = 0.5)
  }
  if (attr(x, "scale") == "natural") {
    plot <- plot + scale_y_continuous(trans = "log2")
  }
  plot <- plot +
    facet_wrap(eval(parse(text = facet_formula(covariates)))) +
    guides(fill = guide_legend(title = "Titre type"),
           colour = "none")
  if (!is.null(data)) {
    plot <- add_limits(plot, upper_censoring_limit, lower_censoring_limit)
  }
  plot
}

#' Plot method for "biokinetics_individual_trajectories" class
#'
#' @param x An object of class "biokinetics_individual_trajectories". These are
#' generated by running biokinetics$simulate_individual_trajectories(). See
#' \href{../../epikinetics/html/biokinetics.html#method-biokinetics-simulate_individaul_trajectories}{\code{biokinetics$simulate_individual_trajectories()}}
#' @param \dots Further arguments passed to the method.
#' @param data Optional data.table containing raw data as provided to the biokinetics model.
#' @param min_day Optional minimum date
#' @param max_day Optional maximum date
#' @param pids Optional vector of ids to plot simulated trajectories for a subset of individuals. Can only be used
#' if x has been generated with summarise=FALSE.
#' @param titre_types Optional vector of titre types to include.
#' @export
plot.biokinetics_individual_trajectories <- function(x, ...,
                                                     data = NULL,
                                                     min_day = NULL,
                                                     max_day = NULL,
                                                     pids = NULL,
                                                     titre_types = NULL) {

  # Declare variables to suppress notes when compiling package
  # https://github.com/Rdatatable/data.table/issues/850#issuecomment-259466153
  calendar_day <- value <- me <- mu <- titre_type <- day <- pid <- NULL
  ind_mu_sum <- lo <- hi <- draw <- NULL

  if (is.null(min_day)) {
    min_day <- min(x$calendar_day)
  }
  if (is.null(max_day)) {
    max_day <- max(x$calendar_day)
  }
  if (!is.null(titre_types)) {
    x <- x[titre_type %in% titre_types,]
  }
  if (attr(x, "summarised")) {
    if (!is.null(pids)) {
      stop(paste("Trajectories for specific individuals cannot be extracted if the results are already summarised.",
                 "Generate un-summarised trajectories with biokinetics$simulate_individual_trajectories(summarise=FALSE)"))
    }
    plot <- ggplot(x[calendar_day >= min_day & calendar_day <= max_day,]) +
      geom_line(aes(x = calendar_day, y = me, group = titre_type, colour = titre_type)) +
      geom_ribbon(aes(x = calendar_day,
                      ymin = lo,
                      ymax = hi,
                      fill = titre_type,
                      group = titre_type), alpha = 0.5)
  } else {
    if (is.null(pids)) {
      x <- x[
        !is.nan(mu), .(ind_mu_sum = mean(mu)),
        by = c("calendar_day", "pid", "titre_type")]
      count <- x[, .(count = data.table::uniqueN(pid)), by = .(calendar_day)]
      plot <- ggplot(x[calendar_day >= min_day & calendar_day <= max_day,]) +
        geom_line(aes(x = calendar_day, y = ind_mu_sum,
                      colour = titre_type, group = interaction(titre_type, pid)),
                  alpha = 0.5, linewidth = 0.1) +
        geom_smooth(
          aes(x = calendar_day,
              y = ind_mu_sum,
              fill = titre_type,
              colour = titre_type,
              group = titre_type),
          alpha = 0.5, span = 0.2, show.legend = FALSE) +
        scale_y_continuous(sec.axis = sec_axis(~., name = "Number of data points")) +
        geom_bar(data = count[calendar_day >= min_day & calendar_day <= max_day,],
                 aes(x = calendar_day, y = count),
                 stat = "identity", alpha = 0.6)
    } else {
      x <- x[pid %in% pids & !is.nan(mu),]
      plot <- ggplot(x[calendar_day >= min_day & calendar_day <= max_day,]) +
        geom_line(aes(x = calendar_day, y = mu,
                      colour = titre_type, group = interaction(titre_type, pid, draw)),
                  linewidth = 0.1, alpha = 0.5
        )
    }
  }
  if (!is.null(data)) {
    validate_required_cols(data, c("day", "value"))
    if (!is.null(titre_types)) {
      data <- data[titre_type %in% titre_types,]
    }
    if (!is.null(pids)) {
      validate_required_cols(data, "pid")
      data <- data[pid %in% pids,]
    }
    plot <- plot +
      geom_point(data = data[day >= min_day & day <= max_day,],
                 aes(x = day,
                     y = value,
                     colour = titre_type), size = 0.5)
  }
  plot +
    labs(x = "Date",
         y = expression(paste("Titre (IC"[50], ")"))) +
    scale_x_date(date_labels = "%b %Y") +
    guides(colour = guide_legend(title = "Titre type", override.aes = list(alpha = 1, linewidth = 1)),
           fill = "none")
}

#' Plot method for "biokinetics_population_stationary_points" class
#'
#' @param x An object of class "biokinetics_population_stationary_points". These are
#' generated by running biokinetics$population_stationary_points(). See
#' \href{../../epikinetics/html/biokinetics.html#method-biokinetics-population_stationary_points}{\code{biokinetics$population_stationary_points()}}
#' @param \dots Further arguments passed to the method.
#' @param upper_detection_limit Numeric. Optional upper detection limit. Will be plotted as a dotted line.
#' @export
plot.biokinetics_population_stationary_points <- function(x, ..., upper_detection_limit = NULL) {
  # Declare variables to suppress notes when compiling package
  # https://github.com/Rdatatable/data.table/issues/850#issuecomment-259466153
  mu_p <- mu_s <- mu_p_me <- mu_s_me <- titre_type <- NULL
  covariates <- attr(x, "covariates")
  plot <- ggplot(data = x,
                 aes(x = mu_p, y = mu_s, colour = titre_type)) +
    geom_density_2d(aes(group = eval(parse(text = shape_formula(c("titre_type", covariates)))))) +
    geom_point(alpha = 0.05, size = 0.2)

  if (length(covariates) > 0) {
    plot <- plot +
      geom_point(aes(x = mu_p_me,
                     y = mu_s_me,
                     shape = eval(parse(text = shape_formula(covariates)))),
                 colour = "black") +
      guides(shape = guide_legend(title = shape_legend_title(covariates),
                                  override.aes = list(alpha = 1, size = 1)))
  }
  else {
    plot <- plot + geom_point(aes(x = mu_p_me, y = mu_s_me), colour = "black")
  }

  if (attr(x, "scale") == "natural") {
    plot <- plot +
      scale_y_continuous(trans = "log2") +
      scale_x_continuous(trans = "log2")
  }

  if (!is.null(upper_detection_limit)) {
    plot <- plot +
      geom_vline(xintercept = upper_detection_limit, linetype = "twodash", colour = "gray30") +
      geom_hline(yintercept = upper_detection_limit, linetype = "twodash", colour = "gray30")
  }

  plot +
    geom_path(aes(x = mu_p_me, y = mu_s_me, group = titre_type), colour = "black") +
    labs(x = expression(paste("Population-level titre value at peak (IC"[50], ")")),
         y = expression(paste("Population-level titre value at set-point (IC"[50], ")"))) +
    guides(colour = guide_legend(override.aes = list(alpha = 1, size = 1)))

}

facet_formula <- function(covariates) {
  paste("~", paste(c("titre_type", covariates), collapse = "+"))
}

add_limits <- function(plot, upper_censoring_limit, lower_censoring_limit) {
  if (!is.null(lower_censoring_limit)) {
    plot <- plot +
      geom_hline(yintercept = lower_censoring_limit,
                 linetype = 'dotted') +
      annotate("text", x = 1,
               y = lower_censoring_limit,
               label = "Lower detection limit",
               vjust = -0.5,
               hjust = 0,
               size = 3)
  }
  if (!is.null(upper_censoring_limit)) {
    plot <- plot +
      geom_hline(yintercept = upper_censoring_limit,
                 linetype = 'dotted') +
      annotate("text", x = 1,
               y = upper_censoring_limit,
               label = "Upper detection limit",
               vjust = -0.5,
               hjust = 0,
               size = 3)
  }
  plot
}

shape_formula <- function(covariates) {
  paste0("interaction(", paste(covariates, collapse = ","), ")")
}

shape_legend_title <- function(covariates) {
  if (length(covariates) == 1) {
    return(covariates[[1]])
  } else {
    return(shape_formula(covariates))
  }
}
